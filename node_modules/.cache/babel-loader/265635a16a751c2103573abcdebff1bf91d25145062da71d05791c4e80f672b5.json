{"ast":null,"code":"import _objectSpread from \"C:/Users/Ashok/Desktop/Ecommerce app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"C:/Users/Ashok/Desktop/Ecommerce app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Ashok/Desktop/Ecommerce app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { extractEventInfo } from '../events/event-info.mjs';\nimport { sync, cancelSync } from '../frameloop/index.mjs';\nimport { secondsToMilliseconds } from '../utils/time-conversion.mjs';\nimport { addPointerEvent } from '../events/use-pointer-event.mjs';\nimport { pipe } from '../utils/pipe.mjs';\nimport { distance2D } from '../utils/distance.mjs';\nimport { frameData } from '../frameloop/data.mjs';\nimport { isPrimaryPointer } from '../events/utils/is-primary-pointer.mjs';\n\n/**\n * @internal\n */\nvar PanSession = /*#__PURE__*/function () {\n  function PanSession(event, handlers) {\n    var _this = this;\n    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      transformPagePoint = _ref.transformPagePoint;\n    _classCallCheck(this, PanSession);\n    /**\n     * @internal\n     */\n    this.startEvent = null;\n    /**\n     * @internal\n     */\n    this.lastMoveEvent = null;\n    /**\n     * @internal\n     */\n    this.lastMoveEventInfo = null;\n    /**\n     * @internal\n     */\n    this.handlers = {};\n    this.updatePoint = function () {\n      if (!(_this.lastMoveEvent && _this.lastMoveEventInfo)) return;\n      var info = getPanInfo(_this.lastMoveEventInfo, _this.history);\n      var isPanStarted = _this.startEvent !== null;\n      // Only start panning if the offset is larger than 3 pixels. If we make it\n      // any larger than this we'll want to reset the pointer history\n      // on the first update to avoid visual snapping to the cursoe.\n      var isDistancePastThreshold = distance2D(info.offset, {\n        x: 0,\n        y: 0\n      }) >= 3;\n      if (!isPanStarted && !isDistancePastThreshold) return;\n      var point = info.point;\n      var timestamp = frameData.timestamp;\n      _this.history.push(_objectSpread(_objectSpread({}, point), {}, {\n        timestamp: timestamp\n      }));\n      var _this$handlers = _this.handlers,\n        onStart = _this$handlers.onStart,\n        onMove = _this$handlers.onMove;\n      if (!isPanStarted) {\n        onStart && onStart(_this.lastMoveEvent, info);\n        _this.startEvent = _this.lastMoveEvent;\n      }\n      onMove && onMove(_this.lastMoveEvent, info);\n    };\n    this.handlePointerMove = function (event, info) {\n      if (!isPrimaryPointer(event)) return;\n      _this.lastMoveEvent = event;\n      _this.lastMoveEventInfo = transformPoint(info, _this.transformPagePoint);\n      // Throttle mouse move event to once per frame\n      sync.update(_this.updatePoint, true);\n    };\n    this.handlePointerUp = function (event, info) {\n      if (!isPrimaryPointer(event)) return;\n      _this.end();\n      var _this$handlers2 = _this.handlers,\n        onEnd = _this$handlers2.onEnd,\n        onSessionEnd = _this$handlers2.onSessionEnd;\n      var panInfo = getPanInfo(transformPoint(info, _this.transformPagePoint), _this.history);\n      if (_this.startEvent && onEnd) {\n        onEnd(event, panInfo);\n      }\n      onSessionEnd && onSessionEnd(event, panInfo);\n    };\n    // If we have more than one touch, don't start detecting this gesture\n    if (!isPrimaryPointer(event)) return;\n    this.handlers = handlers;\n    this.transformPagePoint = transformPagePoint;\n    var info = extractEventInfo(event);\n    var initialInfo = transformPoint(info, this.transformPagePoint);\n    var point = initialInfo.point;\n    var timestamp = frameData.timestamp;\n    this.history = [_objectSpread(_objectSpread({}, point), {}, {\n      timestamp: timestamp\n    })];\n    var onSessionStart = handlers.onSessionStart;\n    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));\n    this.removeListeners = pipe(addPointerEvent(window, \"pointermove\", this.handlePointerMove), addPointerEvent(window, \"pointerup\", this.handlePointerUp), addPointerEvent(window, \"pointercancel\", this.handlePointerUp));\n  }\n  _createClass(PanSession, [{\n    key: \"updateHandlers\",\n    value: function updateHandlers(handlers) {\n      this.handlers = handlers;\n    }\n  }, {\n    key: \"end\",\n    value: function end() {\n      this.removeListeners && this.removeListeners();\n      cancelSync.update(this.updatePoint);\n    }\n  }]);\n  return PanSession;\n}();\nfunction transformPoint(info, transformPagePoint) {\n  return transformPagePoint ? {\n    point: transformPagePoint(info.point)\n  } : info;\n}\nfunction subtractPoint(a, b) {\n  return {\n    x: a.x - b.x,\n    y: a.y - b.y\n  };\n}\nfunction getPanInfo(_ref2, history) {\n  var point = _ref2.point;\n  return {\n    point: point,\n    delta: subtractPoint(point, lastDevicePoint(history)),\n    offset: subtractPoint(point, startDevicePoint(history)),\n    velocity: getVelocity(history, 0.1)\n  };\n}\nfunction startDevicePoint(history) {\n  return history[0];\n}\nfunction lastDevicePoint(history) {\n  return history[history.length - 1];\n}\nfunction getVelocity(history, timeDelta) {\n  if (history.length < 2) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n  var i = history.length - 1;\n  var timestampedPoint = null;\n  var lastPoint = lastDevicePoint(history);\n  while (i >= 0) {\n    timestampedPoint = history[i];\n    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {\n      break;\n    }\n    i--;\n  }\n  if (!timestampedPoint) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n  var time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1000;\n  if (time === 0) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n  var currentVelocity = {\n    x: (lastPoint.x - timestampedPoint.x) / time,\n    y: (lastPoint.y - timestampedPoint.y) / time\n  };\n  if (currentVelocity.x === Infinity) {\n    currentVelocity.x = 0;\n  }\n  if (currentVelocity.y === Infinity) {\n    currentVelocity.y = 0;\n  }\n  return currentVelocity;\n}\nexport { PanSession };","map":{"version":3,"names":["extractEventInfo","sync","cancelSync","secondsToMilliseconds","addPointerEvent","pipe","distance2D","frameData","isPrimaryPointer","PanSession","event","handlers","transformPagePoint","startEvent","lastMoveEvent","lastMoveEventInfo","updatePoint","info","getPanInfo","history","isPanStarted","isDistancePastThreshold","offset","x","y","point","timestamp","push","onStart","onMove","handlePointerMove","transformPoint","update","handlePointerUp","end","onEnd","onSessionEnd","panInfo","initialInfo","onSessionStart","removeListeners","window","subtractPoint","a","b","delta","lastDevicePoint","startDevicePoint","velocity","getVelocity","length","timeDelta","i","timestampedPoint","lastPoint","time","currentVelocity","Infinity"],"sources":["C:/Users/Ashok/Desktop/Ecommerce app/node_modules/framer-motion/dist/es/gestures/PanSession.mjs"],"sourcesContent":["import { extractEventInfo } from '../events/event-info.mjs';\nimport { sync, cancelSync } from '../frameloop/index.mjs';\nimport { secondsToMilliseconds } from '../utils/time-conversion.mjs';\nimport { addPointerEvent } from '../events/use-pointer-event.mjs';\nimport { pipe } from '../utils/pipe.mjs';\nimport { distance2D } from '../utils/distance.mjs';\nimport { frameData } from '../frameloop/data.mjs';\nimport { isPrimaryPointer } from '../events/utils/is-primary-pointer.mjs';\n\n/**\n * @internal\n */\nclass PanSession {\n    constructor(event, handlers, { transformPagePoint } = {}) {\n        /**\n         * @internal\n         */\n        this.startEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEventInfo = null;\n        /**\n         * @internal\n         */\n        this.handlers = {};\n        this.updatePoint = () => {\n            if (!(this.lastMoveEvent && this.lastMoveEventInfo))\n                return;\n            const info = getPanInfo(this.lastMoveEventInfo, this.history);\n            const isPanStarted = this.startEvent !== null;\n            // Only start panning if the offset is larger than 3 pixels. If we make it\n            // any larger than this we'll want to reset the pointer history\n            // on the first update to avoid visual snapping to the cursoe.\n            const isDistancePastThreshold = distance2D(info.offset, { x: 0, y: 0 }) >= 3;\n            if (!isPanStarted && !isDistancePastThreshold)\n                return;\n            const { point } = info;\n            const { timestamp } = frameData;\n            this.history.push({ ...point, timestamp });\n            const { onStart, onMove } = this.handlers;\n            if (!isPanStarted) {\n                onStart && onStart(this.lastMoveEvent, info);\n                this.startEvent = this.lastMoveEvent;\n            }\n            onMove && onMove(this.lastMoveEvent, info);\n        };\n        this.handlePointerMove = (event, info) => {\n            if (!isPrimaryPointer(event))\n                return;\n            this.lastMoveEvent = event;\n            this.lastMoveEventInfo = transformPoint(info, this.transformPagePoint);\n            // Throttle mouse move event to once per frame\n            sync.update(this.updatePoint, true);\n        };\n        this.handlePointerUp = (event, info) => {\n            if (!isPrimaryPointer(event))\n                return;\n            this.end();\n            const { onEnd, onSessionEnd } = this.handlers;\n            const panInfo = getPanInfo(transformPoint(info, this.transformPagePoint), this.history);\n            if (this.startEvent && onEnd) {\n                onEnd(event, panInfo);\n            }\n            onSessionEnd && onSessionEnd(event, panInfo);\n        };\n        // If we have more than one touch, don't start detecting this gesture\n        if (!isPrimaryPointer(event))\n            return;\n        this.handlers = handlers;\n        this.transformPagePoint = transformPagePoint;\n        const info = extractEventInfo(event);\n        const initialInfo = transformPoint(info, this.transformPagePoint);\n        const { point } = initialInfo;\n        const { timestamp } = frameData;\n        this.history = [{ ...point, timestamp }];\n        const { onSessionStart } = handlers;\n        onSessionStart &&\n            onSessionStart(event, getPanInfo(initialInfo, this.history));\n        this.removeListeners = pipe(addPointerEvent(window, \"pointermove\", this.handlePointerMove), addPointerEvent(window, \"pointerup\", this.handlePointerUp), addPointerEvent(window, \"pointercancel\", this.handlePointerUp));\n    }\n    updateHandlers(handlers) {\n        this.handlers = handlers;\n    }\n    end() {\n        this.removeListeners && this.removeListeners();\n        cancelSync.update(this.updatePoint);\n    }\n}\nfunction transformPoint(info, transformPagePoint) {\n    return transformPagePoint ? { point: transformPagePoint(info.point) } : info;\n}\nfunction subtractPoint(a, b) {\n    return { x: a.x - b.x, y: a.y - b.y };\n}\nfunction getPanInfo({ point }, history) {\n    return {\n        point,\n        delta: subtractPoint(point, lastDevicePoint(history)),\n        offset: subtractPoint(point, startDevicePoint(history)),\n        velocity: getVelocity(history, 0.1),\n    };\n}\nfunction startDevicePoint(history) {\n    return history[0];\n}\nfunction lastDevicePoint(history) {\n    return history[history.length - 1];\n}\nfunction getVelocity(history, timeDelta) {\n    if (history.length < 2) {\n        return { x: 0, y: 0 };\n    }\n    let i = history.length - 1;\n    let timestampedPoint = null;\n    const lastPoint = lastDevicePoint(history);\n    while (i >= 0) {\n        timestampedPoint = history[i];\n        if (lastPoint.timestamp - timestampedPoint.timestamp >\n            secondsToMilliseconds(timeDelta)) {\n            break;\n        }\n        i--;\n    }\n    if (!timestampedPoint) {\n        return { x: 0, y: 0 };\n    }\n    const time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1000;\n    if (time === 0) {\n        return { x: 0, y: 0 };\n    }\n    const currentVelocity = {\n        x: (lastPoint.x - timestampedPoint.x) / time,\n        y: (lastPoint.y - timestampedPoint.y) / time,\n    };\n    if (currentVelocity.x === Infinity) {\n        currentVelocity.x = 0;\n    }\n    if (currentVelocity.y === Infinity) {\n        currentVelocity.y = 0;\n    }\n    return currentVelocity;\n}\n\nexport { PanSession };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}